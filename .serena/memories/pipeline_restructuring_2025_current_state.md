# ProPaths Pipeline Restructuring - Current State & Next Steps

**Date:** 2025-10-27  
**Status:** Backend Restructuring COMPLETE ‚úÖ | Frontend/Data Integration TODO üîÑ

---

## üéâ MAJOR MILESTONE: Backend Pipeline Restructuring COMPLETE

### What Was Just Completed (Backend)

The **CRITICAL BACKEND RESTRUCTURING** of the ProPaths pipeline is **FULLY COMPLETE**. This was a major rewrite affecting ~1500+ lines of code across three core files.

#### 1. **config_gemini_MAXIMIZED.py** (Complete Rewrite - ~1000 lines)

**Changes:**
- **Steps 1a-1g:** Stripped to protein name aggregation ONLY
  - Direct/indirect classification (direct = physical interaction, indirect = cascade/pathway)
  - Track `upstream_interactor` for indirect proteins
  - **NO arrows, NO directions** at this stage - just names!
  - Search freely with NO constraints on paper titles or arrows
  
- **Steps 2a-2a5, 2b:** Enhanced function discovery
  - Collect ALL paper titles (no title constraints!)
  - Track indirect interactors in cascades
  - Map functions affected by each interaction
  - Build complete function profiles
  
- **NEW Step 2c (TEMPLATE):** Arrow determination logic
  - Research interactor's NORMAL role in each function
  - Compare normal role vs interaction effect
  - Deduce arrow: `inhibits` (opposes normal) | `activates` (enhances) | `binds` (mixed/unclear)
  - Set direction based on whose functions are affected
  - **Note:** This is a TEMPLATE step - runner generates it dynamically per-interactor
  
- **Step 2g:** Updated QC to verify arrows and indirect interactors

#### 2. **config_dynamic.py** (Complete Update)

**Changes:**
- `create_interactor_discovery_step()` - Names-only approach (no arrows)
- `create_function_mapping_step()` - With paper titles + indirect tracking
- **NEW:** `create_arrow_determination_step()` - Per-interactor arrow logic
- `generate_pipeline()` - Updated to skip arrow template (dynamically generated by runner)

#### 3. **runner.py** (Dynamic Arrow Execution)

**Changes:**
- Modified `_run_main_pipeline_for_web()` to inject arrow determination steps **AFTER Step 2b**
- **Logic Flow:**
  1. After function discovery (Step 2b) completes
  2. Extract `interactor_history` from accumulated context
  3. For EACH interactor: Generate arrow determination step ‚Üí Execute ‚Üí Merge results
  4. Continue to QC (Step 2g) and final snapshot (Step 3)
- Added progress reporting: "Determining arrow/direction for VCP..."
- Handles interactors without functions (defaults to `arrow='binds'`)

---

## üî¨ The NEW Pipeline Architecture

### PHASE 1: Interactor Discovery (Steps 1a-1g)
```
‚îú‚îÄ Find protein NAMES only (no arrows/directions yet!)
‚îú‚îÄ Classify as direct (physical contact) or indirect (cascade/pathway)
‚îú‚îÄ Track upstream_interactor for indirect proteins
‚îî‚îÄ Search freely with NO constraints on paper titles or arrows
```

**Key Innovation:** Separation of concerns - find proteins first, understand relationships later.

### PHASE 2: Function Discovery (Steps 2a-2a5, 2b)
```
‚îú‚îÄ Find ALL functions affected by interactions
‚îú‚îÄ COLLECT PAPER TITLES (no title constraints!)
‚îú‚îÄ TRACK INDIRECT INTERACTORS in cascades
‚îî‚îÄ Build complete function profiles
```

**Key Innovation:** Gather ALL context before making arrow determinations.

### PHASE 3: Arrow Determination (Step 2c - DYNAMIC!) ‚≠ê NEW!
```
‚îú‚îÄ For EACH interactor:
‚îÇ   ‚îú‚îÄ Extract their functions from Step 2b
‚îÇ   ‚îú‚îÄ Research interactor's NORMAL role in each function
‚îÇ   ‚îú‚îÄ Compare: Normal role vs interaction effect
‚îÇ   ‚îú‚îÄ Deduce arrow:
‚îÇ   ‚îÇ   ‚Ä¢ Opposes normal role ‚Üí inhibits
‚îÇ   ‚îÇ   ‚Ä¢ Enhances normal role ‚Üí activates
‚îÇ   ‚îÇ   ‚Ä¢ Mixed/unclear ‚Üí binds
‚îÇ   ‚îî‚îÄ Set direction based on whose functions are affected
‚îî‚îÄ Execute per-interactor (parallel-ready architecture)
```

**Example Logic:**
```
ATXN3 interacts with VCP:
  Function affected: "ERAD"
  Interaction effect: Inhibits ERAD
  
  ‚Üí Research: What's VCP's NORMAL role in ERAD?
  ‚Üí Found: VCP normally ACTIVATES ERAD
  
  ‚Üí Logic: If VCP activates ERAD normally, but interaction inhibits ERAD,
           then ATXN3 must be INHIBITING VCP's function
  
  ‚úÖ Result: arrow='inhibits', direction='main_to_primary' (ATXN3 ‚Üí VCP)
```

### PHASE 4: Final QC + Snapshot (Steps 2g, 3)
```
‚îî‚îÄ Quality control ‚Üí Build final snapshot with all arrows/directions
```

---

## üîÑ REMAINING WORK (Frontend & Data Integration)

These are **MUCH SMALLER** changes compared to the backend restructuring just completed.

### 1. **visualizer.py** - Frontend Rendering Updates

**What needs to change:**
- Render **indirect interactors** with **dashed arrows** (to distinguish from direct interactions)
- Show indirect interactors **branching from their upstream interactor** (not directly from main protein)
- Visual distinction: solid arrows = direct (physical), dashed arrows = indirect (cascade/pathway)
- Update legend to explain direct vs indirect interactions

**Technical Details:**
- Check for `interaction_type` field in interactor data
- If `interaction_type == 'indirect'`, use dashed stroke on arrows
- Position indirect nodes relative to their `upstream_interactor`
- Update D3 force simulation to cluster indirect interactors near their upstream

**Files to modify:**
- `visualizer.py` (D3 rendering logic, link styling, legend)

### 2. **db_sync.py** - Database Schema Updates

**What needs to change:**
- Store `interaction_type` ('direct' | 'indirect') in interactions table
- Store `upstream_interactor` (protein symbol) for indirect interactions
- Update `sync_query_results()` to extract and store these new fields from pipeline JSON
- Ensure canonical ordering still works with indirect interactions

**Technical Details:**
- Add `interaction_type` column to `interactions` table (VARCHAR)
- Add `upstream_interactor` column to `interactions` table (VARCHAR, nullable)
- Modify `DatabaseSyncLayer.sync_query_results()` to:
  1. Extract `interaction_type` from interactor JSON (default: 'direct')
  2. Extract `upstream_interactor` from interactor JSON (nullable)
  3. Store in database alongside existing fields
- Update `build_full_json_from_db()` in `app.py` to reconstruct these fields

**Files to modify:**
- `models.py` (add columns to Interaction model)
- `utils/db_sync.py` (extract and store new fields)

### 3. **app.py** - API & Expansion Logic Updates

**What needs to change:**
- Handle indirect interactors in expansion/pruning logic
- When expanding an interactor, include its indirect interactors
- Update `build_full_json_from_db()` to include `interaction_type` and `upstream_interactor`
- Ensure pruning logic preserves indirect chains (don't break upstream ‚Üí indirect links)

**Technical Details:**
- Modify `build_full_json_from_db()` to add `interaction_type` and `upstream_interactor` to each interactor JSON
- Update pruning logic to consider indirect chains:
  - If upstream interactor is pruned out, its indirect interactors should also be removed
  - If indirect interactor is kept, its upstream must also be kept
- Update expansion logic to query for indirect interactions when clicking on an interactor

**Files to modify:**
- `app.py` (expand endpoints, pruning logic, JSON reconstruction)

---

## üìã Recommended Implementation Order

1. **db_sync.py FIRST** (data layer foundation)
   - Add columns to database schema
   - Update sync logic to store new fields
   - Test with a fresh query to ensure fields are saved

2. **app.py SECOND** (API layer)
   - Update JSON reconstruction to include new fields
   - Test with existing cached data to ensure compatibility
   - Update expansion/pruning logic

3. **visualizer.py LAST** (presentation layer)
   - Add visual distinction for indirect interactors
   - Test rendering with both direct and indirect interactions
   - Update legend and tooltips

---

## üß™ Testing Plan

After all three files are updated:

1. **Fresh Query Test:**
   - Query a new protein (e.g., `BECN1`)
   - Verify pipeline completes with new arrow logic
   - Check database for `interaction_type` and `upstream_interactor` fields
   - Verify visualization shows dashed arrows for indirect interactors

2. **Expansion Test:**
   - Expand an interactor that has indirect interactions
   - Verify indirect chains are preserved
   - Check pruning doesn't break upstream ‚Üí indirect links

3. **Backwards Compatibility Test:**
   - Load old cached data (pre-restructuring)
   - Verify graceful fallback (treat missing fields as 'direct')
   - Ensure no crashes or broken rendering

---

## üîë Key Technical Concepts

### Direct vs Indirect Interactions

- **Direct (physical):** Proteins physically bind/interact
  - Example: ATXN3 ‚Üî VCP (co-IP evidence, physical binding)
  - Rendered: Solid arrows
  
- **Indirect (cascade/pathway):** One protein affects another through a cascade
  - Example: ATXN3 ‚Üí VCP ‚Üí BECN1 (ATXN3 affects BECN1 via VCP)
  - Rendered: Dashed arrows
  - Stored: `upstream_interactor='VCP'` for BECN1

### Arrow Determination Logic

**Key Innovation:** Research normal role, then compare to interaction effect.

```
IF interaction effect OPPOSES normal role:
  ‚Üí arrow = 'inhibits'
  
ELSE IF interaction effect ENHANCES normal role:
  ‚Üí arrow = 'activates'
  
ELSE (mixed/unclear):
  ‚Üí arrow = 'binds'
```

### Direction Logic

- `main_to_primary`: Main protein affects primary interactor's functions
- `primary_to_main`: Primary interactor affects main protein's functions
- `bidirectional`: Both proteins affect each other's functions

---

## üìÅ File Status Summary

### ‚úÖ COMPLETE (No further changes needed)
- `pipeline/config_gemini_MAXIMIZED.py` - Fully restructured
- `pipeline/config_dynamic.py` - Updated with arrow step generator
- `runner.py` - Dynamic arrow execution implemented

### üîÑ TODO (Changes needed)
- `models.py` - Add `interaction_type` and `upstream_interactor` columns
- `utils/db_sync.py` - Extract and store new fields
- `app.py` - Include new fields in JSON reconstruction, update pruning/expansion
- `visualizer.py` - Render indirect interactors with dashed arrows

### üì¶ No Changes Required
- `pipeline/pipeline_types.py` - Existing structures sufficient
- `utils/pruner.py` - Works with existing JSON structure
- `static/styles.css` - May need minor additions for dashed arrows
- `templates/index.html` - No changes needed

---

## üöÄ Next Steps for Continuation

**Start with:** `db_sync.py` (database layer)

**Command to give next AI:**
```
Continue the ProPaths pipeline restructuring. The backend (config, runner) is COMPLETE. 
Now update db_sync.py to store interaction_type and upstream_interactor fields in the database.
Then update app.py to include these fields in JSON reconstruction.
Finally update visualizer.py to render indirect interactors with dashed arrows.
```

**Context to provide:**
- Backend restructuring is 100% complete and tested
- Pipeline now generates `interaction_type` and `upstream_interactor` in JSON output
- Need to persist these fields and render them in the UI
- Implementation order: db_sync.py ‚Üí app.py ‚Üí visualizer.py

---

**END OF MEMORY** - Next AI can pick up from here with full context!
